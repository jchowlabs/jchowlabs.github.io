<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/responsive.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="../images/favicon.png">
    <title>jchowlabs</title>
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-GBHGE9LDVJ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-GBHGE9LDVJ');
</script>

<body>
    <header>
        <div class="brand">
            <a href="../index.html" class="brand-link">
                <strong>jchowlabs</strong>
            </a>
        </div>
        <nav>
            <ul>
                <li><a href="../index.html">Labs</a></li>
                <li><a href="../articles.html">Articles</a></li>
                <li><a href="../research.html">Research</a></li>
                <li><a href="../connect.html">Connect</a></li>
            </ul>
        </nav>
    </header>
    
    <main style="display: flex; justify-content: center;">
        <section class="article-content-section" style="width: 100%; display: flex; justify-content: center;">
            <div class="article-container" style="max-width: 890px; width: 100%; padding: 0 20px; box-sizing: border-box;">
                <div class="article-hero">
                    <!-- Placeholder for hero image -->
                    <img src="../images/icons/aftercheck-how-it-works.gif" alt="AfterCheck" class="article-hero-img">
                </div>
                
                <a href="https://www.aftercheck.ai" target="_blank" style="text-decoration: none; display: block;">
                    <div style="background: #f0f7ff; border: 1px solid #2563eb; padding: 30px 36px; margin: 35px 0; border-radius: 12px; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(37, 99, 235, 0.1);">
                        <p style="margin: 0; font-size: 19px; color: #1a1a1a; line-height: 1.6; display: flex; align-items: center; gap: 8px;">
                            <span><strong style="font-size: 17px;">Try yourself:</strong> Get the AfterCheck extension at <span style="color: #2563eb; font-weight: 600; font-size: 17px;">www.aftercheck.ai.</span></span>
                        </p>
                    </div>
                </a>
                
                <div class="article-header">
                    <h1 style="font-size: 2rem;">The Story Behind AfterCheck</h1>
                </div>
                
                <div class="article-body">
                    <p>AfterCheck didn't start as a fact-checking product — it started as an LLM rating system.</p>
                    
                    <p>A friend of mine and I had just built a product focused on pricing security vulnerabilities — a system that rates security vulnerabilities in order to derive price estimates for bug bounty programs. Coming off that work, he shared a new idea with me that bubbled up to a rating system for LLM responses across dimensions like security, bias, ethics, safety, and trust.</p>
                    
                    <p>I wasn't entirely sure how this would work, but the idea resonated.</p>
                    
                    <p>It was the beginning of 2025, and I had just began my year of entrepreneurship. We were both early users of LLMs and encountered many of the same issues everyone else was experiencing along the way — hallucinations, factual inaccuracies, biased framing, ethical concerns, and safety-related problems. To be fair, the technology was still in its infancy and evolving rapidly. But at the same time, adoption of products like ChatGPT, Claude and Perplexity were growing exponentially, which made these issues feel more urgent and worth deeper exploration.</p>
                    
                    <p>Classic me, I built a prototype in about a week — and it was terrible.</p>
                    
                    <p>Not because it didn't work, but because the output was fundamentally unhelpful. The prototype rated each LLM response across bias, ethics, safety, and trust, producing numerical scores for users to interpret. The prototype delivered on the requirements, but in reality, the scores were too abstract for the general user to derive any meaningful value from it.</p>
                    
                    <p>Not all was lost.</p>
                    
                    <p>We had a tangible prototype and an idea that still felt directionally correct — we just needed to refine our understanding of the problem. In classic product management fashion, we started observing how people were using LLMs and focused on nuances where the LLM output triggered some form of skepticism and more importantly, what they naturally did as a result. Patterns were emerging, which we further confirmed through broader but more focused surveys. The feedback consistently converged on a single concern: <strong>factuality.</strong></p>
                    
                    <p>People weren't just worried about whether a response was biased or unsafe — they were struggling to tell whether elements within it were correct. At the time, LLM outputs often sounded confident while containing incorrect, outdated, or unsupported claims. As a result, identifying these issues required constant skepticism and a tendency toward excessive, manual, and time-consuming verification.</p>
                    
                    <p>I was already familiar with solutions attempting to address these problems. On one hand, the LLM providers themselves were building safety, trust, and security mechanisms directly into their platforms — largely focused on preventing harmful or unsafe outputs at the point where generation happens.</p>
                    
                    <p>On the other hand, a wave of third-party tools were also emerging. They were often simple websites with input boxes for users to paste LLM responses into. Many focused on detecting whether content was human versus AI-generated, with some specializing in deepfake detection. I was not aware of any products tackling the factuality problem head on, which seemed like a blue ocean opportunity.</p>
                    
                    <p>All of this led us to a more focused set of questions:</p>
                    
                    <p><strong>Could we build an easy-to-use product that fact-checks LLM responses quickly and reliably — directly inside the tools people already use?</strong></p>
                    
                    <p>The outcome of these questions became AfterCheck.</p>
                    
                    <h2>Product Overview</h2>
                    <p>AfterCheck is a Chromium-based browser extension that automatically activates when a user visits ChatGPT, Claude, or Perplexity sites. The extension monitors conversations between the user and the underlying language model so it can capture both the user's question and the model's response.</p>
                    
                    <p>When a response is captured, AfterCheck sends the question–response pair for fact-checking, then automatically highlights inaccurate claims directly on the original LLM response. Users can hover over a highlighted claim to see additional context — including a correction, supporting evidence, and a confidence score explaining why the claim was flagged.</p>
                    
                    <!-- Placeholder for product demo GIF -->
                    <div class="article-image-placeholder" style="text-align: center; margin-bottom: 30px;">
                        <img src="../images/icons/aftercheck-demo.gif" alt="AfterCheck demonstration" style="width: 90%; display: inline-block; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);">
                    </div>
                    
                    <p>We chose to build AfterCheck as a browser extension because it allowed us to provide value directly in the tools that our users were already using. Asking users to copy and paste responses into a separate website introduces friction, breaks focus, and makes verification feel optional. We saw this pattern in early fact-checking tools, and it simply didn't fit how people actually use LLMs.</p>
                    
                    <h2>Architecture</h2>
                    <p>AfterCheck consists of two main components:</p>
                    <p>(1) a Chromium-based browser extension, and<br>
                    (2) a proprietary fact-checking pipeline.</p>
                    
                    <!-- Architecture diagram -->
                    <div class="article-image-placeholder" style="text-align: center; margin-bottom: 30px;">
                        <img src="../images/icons/aftercheck-diagram.png" alt="AfterCheck Architecture" style="width: 90%; display: inline-block; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);">
                    </div>
                    
                    <p>These components work together to verify the factual accuracy of large language model responses in near real time, directly within the user's existing workflow.</p>
                    
                    <p>The browser extension is responsible for everything that happens inside the user's environment. It detects when a user is interacting with ChatGPT, Claude, or Perplexity, captures the relevant question and response, and manages all client-side behavior — from state tracking and response detection to rendering highlights and hover-over tooltips.</p>
                    
                    <p>Once a question–response pair is captured, it is sent to a backend fact-checking pipeline. At a high level, the backend first extracts claims from the response, provides a true / false verdict for each claim in the context of the original question, then returns the results back to the extension.</p>
                    
                    <p>The extension parses the results, then generates a map of the original response so that inaccurate claims can be highlighted. Highlighted claims include hover-over tooltips that provide additional context such as corrections, confidence levels, and evidence — all without requiring the user to leave their conversation.</p>
                    
                    <p>Lets dig a little deeper into how all of this works.</p>
                    
                    <h2>Detecting and Capturing Conversations</h2>
                    <p>The first step in the AfterCheck journey is detecting when a user initiates a conversation with an LLM, knowing when the LLM has finished responding to that question, then precisely capturing the question-response pair for fact checking.</p>
                    
                    <p>At a high level, there are several established techniques for detecting activity in web applications — each with its own tradeoffs. Options range from monitoring DOM mutations, polling for state changes, or relying on event-based hooks tied to user actions or application lifecycles. Any of these could, in theory, be used to detect when a conversation is happening, determine when a response is complete, and help me capture the resulting content. In practice, each approach differs significantly in signal quality and performance overhead.</p>
                    
                    <p>AfterCheck builds on these techniques to reliably interoperate within ChatGPT, Claude, and Perplexity. The extension combines platform-specific signals and heuristics to identify active conversations and determine when responses are complete.</p>
                    
                    <h3>Understanding the DOM</h3>
                    <p>At the user level, ChatGPT, Claude, and Perplexity have simple, conversation-focused interfaces with a single input box for interacting with the underlying LLM. Under the hood, their DOM structures are moderately complex — and differ in important ways that matter for AfterCheck.</p>
                    
                    <p>The first challenge is detection: how do you reliably identify when a real conversation is actually happening with an LLM?</p>
                    
                    <p>A natural assumption is you monitor the DOM and treat any mutation as signal of an in-progress conversation. This approach breaks down quickly because LLM interfaces are surprisingly noisy. Some interesting observations include page re-rendering or content re-generation due to LLMs updating their internal state. Analytics, telemetry, and general background UI components also contribute to noisy DOMs that give the illusion of activity when there is none.</p>
                    
                    <p>Why does this matter? Because reliable detection is what makes inline fact-checking possible in the first place. AfterCheck needs to capture complete question–response pairs for the fact check pipeline to work effectively. The product also operates on a pay-per-fact-check model so pre-mature or partial captures is a requirement. Admittedly, even though strong detection and capture mechanisms are in place, the extension is vulnerable to DOM changes which have happened several times during my evelopment journey.</p>
                    
                    <p>To solve this, the extension implements lightweight, site-specific DOM mutation observers that activate when the user is on a ChatGPT, Claude, or Perplexity site. Rather than responding to every DOM change, these observers look for specific, high-signal patterns — such as prompt submission events, response streaming behavior, and indicators that a conversation is actively progressing. Only when those signals execute in a specific sequence does the extension proceed with capture.</p>
                    
                    <p>The second challenge is capture: how do you precisely capture both the user's question and corresponding LLM response.</p>
                    
                    <p>To break this down, I studied a vast number of response structures produced across LLM platforms and the underlying DOM representations behind them. The goal was to identify reliable patterns that would allow us to extract content consistently while preserving enough structure for downstream processing.</p>
                    
                    <p>Here are the high level patterns:</p>
                    <ul style="margin-left: 20px; padding-left: 20px;">
                        <li>Short, dense paragraphs</li>
                        <li>Long-form explanatory text</li>
                        <li>Lists or nested bullet points</li>
                        <li>Tables with multiple rows and columns</li>
                        <li>Code blocks</li>
                        <li>Inline formatting, emojis, images, citations, or other enhancing elements</li>
                    </ul>
                    
                    <p>Capturing complete responses requires more than just extracting text. In additional to preserving the structure, we also needto normalize content for the fact-checking pipeline — parsing out elements like emojis, images, and code blocks — while still preserving the original structure of the response so inaccurate claims can later be highlighted in the correct location.</p>
                    
                    <p>This ultimately led to the development of site-specific selectors and parsing mechanisms for each platform, allowing the extension to reliably detect conversations, capture responses, normalize content for fact-checking, and preserve enough structural context for accurate highlighting.</p>
                
                    <h3>Determining When a Response Is Complete</h3>
                    <p>Once a conversation is detected, another critical challenge was determining when an LLM response is actually complete. While this was relatively straightforward on some platforms, it proved far more difficult on others.</p>
                    
                    <p>If you pay close attention to how LLMs render responses, you'll notice completion indicators — UI elements such as copy, refresh, share, or feedback buttons. These indicators typically appear only after a response has fully finished generating, making them a reliable indicators on when a response is complete.</p>
                    
                    <p>In many cases, these indicators worked well as anchors for completion detection. However, one random day, I encountered pre-mature captures on one of the platforms and could not understand why. When visually observing an in-progress response, I did not see any completion indicators, yet logs told me otherwise.</p>
                    
                    <p>It turned out that on one of the platforms, completion indicators are injected into the DOM alongside the response but remain invisible until generation finishes. From a DOM perspective, the elements were present, but from a UI perspective, they hadn't yet transitioned into view.</p>
                    
                    <p>To address this, the extension combines completion indicators with additional signals, such as visibility checks and timing heuristics, to reliably determine when a response has truly finished. While standard indicators like copy and share buttons are sufficient on some platforms, others required more creative solutions to avoid premature capture.</p>
                    
                    <h3>Preventing Duplicate Captures</h3>
                    <p>Another major challenge was ensuring that the same LLM response is never fact-checked twice.</p>
                    
                    <p>Users scroll through conversations, refresh pages, switch tabs, and revisit prior responses frequently. Without safeguards, the extension could easily re-capture and re-process content that has already been fact-checked — leading not only to redundant backend processing, but also to unnecessary consumption of fact-check credits (AfterCheck monetizes with a pay-per-fact check payment model).</p>
                    
                    <p>To prevent this, the extension implements a deduplication mechanism based on hash comparisons. Before initiating a fact check, the extension computes a hash of the full question–response pair and compares it against hashes of responses already processed in local storage. If a matching hash is found, the capture is skipped as the core design.</p>
                    
                    <p>We experimented with hashing partial content — i.e. hashing only the first or last few sentences of a response — but found this approach unreliable. Many LLM responses share similar openings or conclusions, which led to collisions and false positives. Given the relatively short length of each response, computing hashes on full responses was far more reliable without significant overhead.</p>
                    
                    <p>This deduplication mechanism also enabled reliability across page refreshes and tab switches. Even if the DOM is reloaded or the user navigates away and returns, the extension recognizes responses it has already processed so it can avoid redundant fact checks.</p>
                    
                    <p>One edge case we are actively working on involves long-running or historical conversations. Currently, if a user opens a lengthy conversation that has not been fact-checked before, the extension may begin fact-checking the entire visible conversation. To improve this experience, I'm adding more functionality that detect these longer spans of existing content and give the user a choice on what they want to fact check and what they want to skip.</p>
                    
                    <h3>Tab Switching and Page Refreshes</h3>
                    <p>Modern browsers introduce additional complexity when users switch tabs or refresh pages. Background tabs may throttle JavaScript execution, delay DOM updates, or pause observers altogether.</p>
                    
                    <p>The extension is designed to continue tracking DOM mutations even when the user navigates away mid-response. This ensures that responses are still captured and fact-checked correctly once generation completes — even if it happens in the background.</p>
                    
                    <p>Our existing deduplication logic was also helpful in ensuring page refreshes did not trigger redundant fact checks for content that had already been processed.</p>
                    
                    <h3>User Feedback and Controls</h3>
                    <p>Once a response is detected and queued for fact-checking, the extension implements several visual mechanisms as well controls that inform the user what is happening: </p>
                    
                    <ul style="margin-left: 20px; padding-left: 20px;">
                        <li>A toggle with multiple visual queues include progress rings and status indicators</li>
                        <li>An ability to cancel in-progress fact checks via holding the toggle for 3 seconds</li>
                        <li>Toggles to globally disable fact-checking or auto-highlighting</li>
                    </ul>
                    
                    <p>These controls ensure the extension feels assistive rather than intrusive, while still operating automatically by default.</p>
                    
                    <h2>The Fact-Checking Pipeline</h2>
                    <p>Once the extension captures a complete question–response pair, it sends that data to the fact-checking pipeline. While the inner workings of this pipeline are proprietary, the high-level flow can be summarized in three steps:</p>
                    
                    <ol style="margin-left: 20px; padding-left: 20px; margin-bottom: 20px;">
                        <li style="margin-bottom: 15px;"><strong>Claim Extraction</strong> - LLM responses are broken down into individual claims. Each claim is treated as a discrete factual assertion rather than as part of a single block of text, since a single response may contain a mix of correct, incorrect, or ambiguous statements.</li>
                        <li style="margin-bottom: 15px;"><strong>Factuality Evaluation</strong> - Each claim is evaluated for factual accuracy using a proprietary fact-checking pipeline. Claims are assessed in the context of the  question, allowing for more nuanced judgments than evaluating statements in isolation.</li>
                        <li style="margin-bottom: 20px;"><strong>Verdict Generation</strong> - A true or false verdict is assigned to each claim based on scoring mechanism. Claims that fall below a threshold are flagged as inaccurate while others are noted as accurate.</li>
                    </ol>
                    
                    <p>The resulting data is packaged into a structured format and returned to the browser extension. From there, the extension maps these results back onto the original LLM response, highlighting inaccurate claims and surfacing additional context through hover-over tooltips.</p>
                    
                    <h2>Highlighting Inaccurate Claims</h2>
                    <p>Once the extension receives results from the backend fact-checking pipeline, it moves into one of the most visible — and technically challenging — stages of the system: highlighting inaccurate claims back in the original LLM response.</p>
                    
                    <p>From the user's perspective, the goal is simple. Inaccurate claims should be clearly highlighted, and hovering over a highlighted span should surface additional context — including a correction, a confidence score, and supporting evidence. Achieving this reliably across different platforms and response structures was another engineering challenge.</p>
                    
                    <h3>A Multi-Stage Highlighting Algorithm</h3>
                    <p>Once results are returned from the fact-checking pipeline, the extension must determine where — and how — to highlight inaccurate claims in the original response. This turned into a significant engineering challenge for a number of reasons.</p>
                    
                    <p>At a high level, claims can vary widely in how closely they resemble the original text. In some cases, a claim maps directly back to a contiguous span of text. In others, the relationship is far more indirect — spread across multiple sentences, paraphrased, or implied through context rather than explicitly stated.</p>
                    
                    <p>Because of this variability, the system relies on a multi-stage highlighting algorithm rather than a single matching strategy.</p>
                    
                    <p>The first stage attempts an exact phrase match. If an extracted claim corresponds directly to a verbatim span in the LLM response, the extension can confidently highlight that span. This is the simplest and most precise case, and when it works, it produces clean and intuitive highlights.</p>
                    
                    <p>However, exact matches are often the exception rather than the rule.</p>
                    
                    <p>LLMs frequently paraphrase information, restructure sentences, or distribute claims across multiple parts of a response. A single factual assertion may be expressed using different wording, split across sentences, or implied through surrounding context. In these cases, an exact phrase match fails.</p>
                    
                    <p>When that happens, the algorithm progresses to additional stages that use fuzzy matching and related alignment techniques to infer where the claim most likely originated. These stages reason about similarity rather than identity, allowing the extension to locate the best candidate region of text even when wording differs.</p>
                    
                    <p>The goal of the multi-stage approach is not to find any match, but to find the most semantically appropriate place to apply a highlight — minimizing false positives while ensuring that genuinely problematic claims are surfaced.</p>
                    
                    <p>To make this possible, the algorithm needs a structured way to reason about text boundaries and meaning. This is where the concept of atomic blocks becomes foundational.</p>
                    
                    <h3>Atomic Blocks: Defining Meaningful Highlight Boundaries</h3>
                    <p>Rather than operating on raw character offsets or arbitrary DOM nodes, the extension works with atomic blocks — discrete, meaningful units of content such as sentences, list items, or table cells.</p>
                    
                    <p>Atomic blocks provide a semantic layer between the extracted claims and the raw DOM. They ensure that highlights are applied to coherent units of meaning rather than fragmented or misleading spans of text.</p>
                    
                    <p>For example, a claim like "AfterCheck is a browser extension" should map cleanly to a single sentence or list item — not be split across formatting boundaries or DOM elements. Atomic blocks make it possible to reason about text in a way that aligns with how humans read and interpret content.</p>
                    
                    <p>Once claims are matched against atomic blocks, the extension can apply highlights confidently, even when claims are paraphrased or distributed across complex response structures.</p>
                    
                    <h3>Filtering Non-Fact-Checkable Content</h3>
                    <p>Before claims can be matched and highlighted, the extension must first determine what not to consider.</p>
                    
                    <p>Not all content in an LLM response is suitable for fact-checking. Some elements are inherently non-factual, ambiguous, or outside the scope of what a factuality system can reasonably evaluate. To avoid misleading or confusing highlights, the extension explicitly filters out several categories of content during capture and highlighting.</p>
                    
                    <p>These include:</p>
                    <ul style="margin-left: 20px; padding-left: 20px;">
                        <li>Code blocks, where correctness depends on execution context or intent</li>
                        <li>Generated images or videos, which cannot be fact-checked as textual claims</li>
                        <li>Purely decorative or UI elements, such as icons or interface controls</li>
                    </ul>
                    
                    <p>By excluding these elements early, the system narrows its focus to text-based factual assertions — the type of content where fact-checking is both meaningful and actionable. This filtering also simplifies downstream processing by reducing noise and ambiguity during claim extraction and highlighting.</p>
                    
                    <h3>Accounting for Platform-Specific Structure</h3>
                    <p>Even after content has been normalized into atomic blocks, structural differences across platforms still matter.</p>
                    
                    <p>Each supported LLM interface presents content differently, and responses often blend multiple structures within a single answer. A claim may appear as a list item, a table cell, or several sentences deep inside a dense paragraph. In some cases, the subject of a claim is introduced early, while the factual assertion appears much later and relies on implicit references.</p>
                    
                    <p>The highlighting algorithm must account for these structural nuances when mapping claims back to text. This requires awareness of how atomic blocks relate to one another within the broader response — for example, understanding that multiple sentences belong to the same conceptual paragraph, or that a table row represents a distinct factual unit.</p>
                    
                    <p>By preserving enough structural context from the original DOM, the extension can accurately place highlights in a way that feels intuitive to users, even when responses are complex or deeply nested.</p>
                    
                    <h3>Adapting to Constant UI Changes</h3>
                    <p>One final challenge is that none of these platforms are static.</p>
                    
                    <p>The DOM structures of ChatGPT, Claude, and Perplexity evolve over time as each product iterates on its interface. New layouts are introduced, existing elements change, and response structures shift. A highlighting strategy that works perfectly today may break tomorrow if it relies too heavily on brittle assumptions.</p>
                    
                    <p>To remain resilient, the extension is designed to tolerate ongoing UI changes. Site-specific selectors and parsing logic are continuously updated as interfaces evolve, and the highlighting pipeline is built to fail gracefully rather than produce incorrect or misleading highlights.</p>
                    
                    <p>When a new LLM response is detected, any highlights from a previous response are cleared and the latest results are applied fresh. This ensures users always see highlights that correspond to the most recent interaction, even as the underlying UI changes.</p>
                    
                    <h3>Closing the Loop for the User</h3>
                    <p>When all of these pieces come together, the experience feels intentionally simple.</p>
                    
                    <p>Inaccurate or questionable claims are highlighted directly in the LLM response. Hovering over a highlighted span reveals the correction, confidence score, and supporting evidence — all inline, contextual, and without leaving the page.</p>
                    
                    <p>Despite the complexity behind the scenes — from DOM mutation detection to atomic blocks to multi-stage matching — the outcome is minimal by design: a clear, intuitive way for users to see what may be wrong in an LLM response and understand why.</p>
                    
                    <h2>Learnings Along the Way</h2>
                    <p>It's been an amazing journey evolving AfterCheck into what it is today — and even more rewarding to see how people are using it and deriving value from it every day.</p>
                    
                    <p>What started as an internal experiment quickly became a learning process shaped by real users. Early on, a small group of friends and family helped us iterate on the experience, pressure-test the value, and challenge our assumptions. As the product matured, we expanded feedback through broader surveys and controlled beta testing. Over time, interest began to grow organically — people weren't just curious to test AfterCheck, they wanted to use it as part of their actual workflow.</p>
                    
                    <p>One pattern became clear very quickly: people who rely on LLM outputs for real work cared deeply about factuality — but only if verification was effortless.</p>
                    
                    <p>Researchers and academic users were among the first to adopt AfterCheck in meaningful ways. Many already used LLMs for exploratory research, synthesis, or background understanding, but struggled to confidently separate sound claims from subtle inaccuracies. Inline highlights helped them quickly identify which parts of a response deserved closer scrutiny, making LLMs more useful as research aids — not because the models became perfect, but because uncertainty became visible.</p>
                    
                    <p>We saw similar behavior from lawyers and other knowledge-intensive professionals. When reviewing LLM-generated summaries of cases, laws, or principles, small inaccuracies or outdated references can matter a great deal. AfterCheck didn't replace expertise, but it helped surface where deeper verification was needed — especially in nuanced or high-stakes scenarios.</p>
                    
                    <p>Across all of these use cases, one lesson stood out: inline matters.</p>
                    
                    <p>Tools that required users to leave ChatGPT, Claude, or Perplexity — even when they offered similar functionality — struggled to see sustained adoption. Copying and pasting responses into separate websites added friction and broke focus. AfterCheck worked differently because it stayed in context. By surfacing factual signals directly on the response itself, verification became a natural extension of the interaction rather than an extra step. Many users described the highlights as a kind of "heat map" — an immediate visual cue for where attention was needed.</p>
                    
                    <h2>Closing Thoughts</h2>
                    <p>AfterCheck didn't start as a fact-checking product. It started as a broader exploration of trust — how to evaluate LLM responses across dimensions like safety, bias, ethics, and reliability. Over time, through personal use, conversations, and surveys, that exploration converged on a simple but powerful insight: factuality is where trust breaks down most often — and where better tooling can have immediate impact.</p>
                    
                    <p>There's still a lot of work ahead. Improving accuracy, reliability, and scalability is an ongoing process. But one lesson has remained consistent throughout this journey: trust in AI systems doesn't come from eliminating mistakes entirely. It comes from making uncertainty visible and verification effortless.</p>
                    
                    <p>Fun fact - it took ~10,000 questions (and counting) across ChatGPT, Claude and Perplexity to build and refine AfterCheck into the product it is today :)</p>
                </div>
            </div>
        </section>
    </main>
    
    <footer>
        <p>© jchowlabs</p>
    </footer>
    
</body>
</html